HW 11 textbook solutions
===========
Author:    Luke Dercher
Email:     luke.dercher@gmail.com
===========

.ap1.
--------------------

 Use the master theorem to find the Θ-class of each of the following recurrences.
(i) T(n) = 2T(n/4) + 1.

    we have a = 2, b = 4, and f(n) = theta(n^c) where c = 0  
    we also have log_b a = 1/2
    since c is less than log_b a we have the T(n) = theta(n^(log_b a)) = theta(n^(1/2))
    
(ii) T(n) = 2T(n/4) + √n.

    we have a = 2, b = 4, and f(n) = theta(n^c) where c = 1/2  
    we also have log_b a = 1/2
    since c is equal to log_b a we have the T(n) = theta(n^c * log n) = theta(n^(1/2) * log n)

(iii) T(n) = 2T(n/4) + n.

    we have a = 2, b = 4, and f(n) = theta(n^c) where c = 1  
    we also have log_b a = 1/2
    since c is grater than log_b a we have the T(n) = theta(f(n)) = theta(n)

(iv) T(n) = 2T(n/4) + n^2

    we have a = 2, b = 4, and f(n) = theta(n^c) where c = 2  
    we also have log_b a = 1/2
    since c is greater than log_b a we have the T(n) = theta(f(n)) = theta(n^2)

--------------------

.ap2.
--------------------

Can the master theorem be applied to the recurrence T(n) = 4T(n/2) + n^2(log(n))? Why or why not?
Give a good asymptotic upper bound for it.

    note: the difference between f(n) and n^(log_b a) can be expressed f(n)/n^(log_2 4) = (n^2(log n))/ n ^2 = 1 / log n which is not < n^e for any constant e
    Therefore the difference is not polynomial and the master theroom does not apply.

    analysis: T(n) = 4T(n/2) + n^2*log n = 4(4(T((n-1)/2) + (n/2)^2 * log(n/2)) + n^2 * log n
              T(n) = 4(4(4(T((n-2)/2) + ((n-1)/2)^2 * log ((n-1)/2)) + (n/2)^2*log(n/2)) + n^2 * log n

    observe T(n) is dominated by the (n-k/2)^2 term. Therefore T(n) is upper bounded by (n/2)^2


--------------------

 
 
.ap3.
--------------------

Show that T(0) = 1, T(n) = T(n-1) + n is O(n^2)

Induction on n

    Base case: 
        T(0) = 1, given

    Assume:
        T(l) = l^2 for l < n

    Show true for n:
        T(n) = T(n-1) + n <= (n-1)^2 + n = n^2 - n + 1
        note: T(n) = n^2 - n + 1 is dominated by n^2 term and is O(n^2)

    Further explanation:
        T(n) = T(n-1) + n = T(n-2) + n + n = T(n - 3) + n + n + n ...
        T(n) = T(n-k) + sum n from 0 to k-1
        choose k = n-1
        T(n) = T(n-(n-1)) + sum n from 0 to n-2
        T(n) = T(1) + n(n-2) = n^2 - n + 1
--------------------


.ap4.
--------------------

Show that T(1) = 10, T(n) = T(ceil(n/2)) + 1 is O(log n)

Induction on n

    Base case: 
        T(1) = 10, given

    Assume: T(l) = log l for l < n

    Show  true for n:
        T(n) = T(ceil(n/2)) <= log(ceil(n/2)) + 1

    Further explanation:
        T(n) = T(ceil(n/2)) + 1 = if (ceil(n/2) = n/2) then T(n) = T(ceil((n-1)/2) + 1 = T(ceil((n-2)/2) + 1 = T(ceil((n-3)/2) + 1 + 1 = T(ceil((n-4)/2) + 1 + 1
                                                       else T(n) = T(ceil((n-1)/2) = T(ceil((n-2)/2) + 1 = T(ceil((n-3)/2) + 1 = T(ceil((n-4)/2) + 1 + 1

        T(n) = T(ceil((n-k)/2)) + sum 1 from 0 to ceil(k/2)
            choose k = n-2
            T(n) = T(1) + sum 1 from 0 to ceil((n-2)/2)
            T(n) = 10 + sum 1 from 0 to ceil((n-2)/2)
            note this summation grows very similiar to log n hence T(n) is bounded by n^2 
--------------------


.ap5.
--------------------

def credit_card(L):
  recurse_lim = math.ceil(len(L)/4)
  cands = call(L,recurse_lim)
  return cands

def call(L,n): # {{{
  if len(L) <= n:
    return L
  cands = []
  mf = int(math.floor(len(L)/2))
  mc = int(math.ceil(len(L)/2))
  cands = (list(overHalf(L,mc)))
  A = call(L[:mc],n)
  B = call(L[mc:(len(L))],n)

  return cands

def overHalf(L, n):
  counter = Counter()
  cands = set()
  for i in L:
    counter[i] += 1
    if counter[i] >= n:
      if i not in cands:
        cands.add(i)

  return cands
--------------------

.ap4.
--------------------

limits recursion depth by ceil(n/4). This gives the ability to check enough of the list to determine if a set of same elems S has |S| = n/4 and still run in contstant time. 
--------------------


.5.6.
--------------------
	
Consider an n-node complete binary tree T, where n=2^d - 1 for some d. Each node v of T is labeled with a real number x_v. You may assume that the real numbers labeling the nodes are all distinct. A node v of T is a local minimum if the label x_v is less than the label x_w for all nodes w that are joined to v by an edge.

You are given such a complete binary tree T, but the labeling is only specified in the following implicit way: for each node v, you can determine the value x_v by probing the node v. Show how to find a local minimum of T using only O(log n) probes to the nodes of T.

L = store tree in list with nodes in same location in list

loacl_min(n)

right = compute right node index of n

if |L| = 0:
    return None 

if |L| == 1:
    return L[1]

else:
    if L[right_node - 1] < L[right] < L[right + 1]:
        local_min(right + 1)
    elif: L[right_node - 1] > L[right] > L[right + 1]:
        local_min(right - 1)
    else:
        return n



--------------------



