HW 12 textbook solutions
===========
Author:    Luke Dercher
Email:     luke.dercher@gmail.com
===========

.ap1.
--------------------
Let (x1, y1), (x2, y2), (x3, y3) be points in R^2
such that x1, x2, x3 are all distinct. Prove directly that
there is a unique polynomial of degree 2 that passes through the points.


If there is not a unique polynomial then there exists at least two polynomials of degree 2 that pass through points (x1, y1), (x2, y2), (x3, y3).
Let P(x) and Q(x) be those polynomials. 
Since P and Q are equal we know that P(x1) = Q(x1), P(x2) = Q(x2), P(x3) = Q(x3)
Lets define a new polynomial of degree two R(x) s.t. R(x) = Q(x) - P(x) 
observe R(x) has three points where R(x) = 0. This cannot happen in a polynomial of degree two and is hence a contradiction -><-
--------------------
 
 
.ap2.
--------------------
 Find a function of the form
f(x) = λ0 + λ1ex + λ2e^2x + λ3e^3x
passing through the points (1, 1), (2, 1), (3, 3), and (4, 4).
we have 

f(1) = λ0 + λ1e(1) + λ2e^2(1) + λ3e^3(1) = 1
f(2) = λ0 + λ1e(2) + λ2e^2(2) + λ3e^3(2) = 1
f(3) = λ0 + λ1e(3) + λ2e^2(3) + λ3e^3(3) = 3
f(4) = λ0 + λ1e(4) + λ2e^2(4) + λ3e^3(4) = 4

we have four equations and four unknowns
solving for the unknowns we have 
λ0 = 1.2866, λ1 = -0.14941, λ2 = 0.016885, λ3 = -0.00025886


--------------------


.ap3.
--------------------
 Recall that if A is an n × n matrix then the determinant of A can be computed by cofactor expansion
along row 1 by
det(A) = sum from k=1 to n of(−1)^(1+k)a_1k det(A1k),
where A1k is the (n − 1) × (n − 1) matrix obtained from A by deleting row 1 and column k.
(i) Write a recursive pseudocode algorithm to compute the determinant of A along row 1.

det(A, n):
     det = 0
     if n < 1:
        return
     elif n == 1:
        det = A[1][0]
     elif n == 2:
         det = A[0][0] * a[1][1] - a[1][0] * a[0][1]
     else:
         for k in range(n):
            for i in range(n):
                for j in range(n):
                    ind = 0
                    if j != i:
                        temp[i-1][ind] = A[i][j]
                        ind += 1
          det += -1^(1+k) * A[1][k]*det(temp,n-1)

      return det
         




(ii) Compute the recurrence for the runtime of your algorithm. [ Hint: it should look something like
T(1) = 1, T(n) = nT(n − 1) + n. ]

we have T(1) = 1 by one of the base cases of the algorithm,
we have T(n) = nT(n-1) + n since det is being called n times with n-1 every time and is performing an operating on each n elements of the matrix. 


(iii) Use a summation factor and the fact that
sum from k = 0 to n 1/k! −→ e
to find the Θ-complexity of your recurrence.


--------------------


